# Class definition for argParser objects

unset argParser_args argParser_objName argParser_unprocessedArgs
declare -Ag argParser_args
declare argParser_objName="${FUNCNAME[2]}"
argParser_unprocessedArgs=()

# argParser.main(): parses provided command line arguments and saves in an assoc array
argParser.main() {
	local key value keyLen
	
	# loop over all args passed and parse the switches and values
	while [ $# -gt 0 ]
	do
		if grep  '='  <<< "$1" | cut -f1 -d= | grep -qvP ' '; then
			# argument takes the form key=VALUE
			key=$(cut -f1 -d= <<< "$1")
			value="${1:$[${#key}+1]}"
			argParser_args[$key]="$value"
			shift
		else
			key="$1"
			if grep -q '^[^-]' <<< "$2"; then
				# argument takes the form --key VALUE or -k VALUE
				argParser_args[$key]="$2"
				shift
				shift
			else
				if grep -q '^-[^-]' <<< "$key"; then
					# argument takes the form -kVALUE or has no value
					keyLen=${#key}
					if [ $keyLen -gt 2 ]; then
						# argument takes the form -kVALUE
						value=${key:2}
					else
						# switch has no value and is of the form -k
						value='true'
					fi
					key=${key:0:2}
					argParser_args[$key]="$value"
				else
					# switch has no value and is of the form --key
					argParser_args[$key]='true'
				fi
				shift
			fi
		fi
	done
}

# argParser.getSwitches(): returns a space-delimited list of switches that were used
argParser.getSwitches() {
	# cannot use echo because it will fail in some cases
	tee /dev/null <<< ${!argParser_args[*]}
}

# argParser.hasSwitch(): expects one or more space-delimited switches. Outputs a space-delimited list of all
#	matching switches that were used. If at least one switch as found, this function returns
#	with a status that evaluates to true. If none were found, this function returns with a
#	status that evaluates to false.
argParser.hasSwitches() {
	local switchFound testSwitches includeSwitches foundSwitches
	testSwitches="$@"
	includedSwitches="$(argParser.getSwitches)"
	if foundSwitches="$(grep -oP "(${includedSwitches// /|})( |$)" <<< "$testSwitches")"; then
		# print out a space-delimited list of switches found; we can't use echo for this because
		# it will lie if only a single switches is returned and is one of the following: -e -E -n
		cat <<< "$foundSwitches" | sed 's/ $//' | tr '\n' ' ' | sed 's/ $//' && echo
		return
	else
		return 1
	fi
}

# argParser.getArg(): accepts one or more switches and returns the associated value for the
#	first-occuring switch that was passed to getArg. So long as the switch was
#	found, the function returns with a status that evaluates to true, otherwise
#	it returns with a status that evaluates to false.
argParser.getArg() {
	local switches firstMatchingSwitch
	if switches=$(argParser.hasSwitches $@); then
		firstMatchingSwitch=$(cut -f1 -d' ' <<< "$switches")
		echo "${argParser_args[$firstMatchingSwitch]}"
		return
	fi
	return 1
}

# argParser.isValidVarName(): helper function for setArgVars(); not intended to be called otherwise
argParser.isValidVarName() {
    echo "$1" | grep -q '^[_[:alpha:]][_[:alpha:][:digit:]]*$' && return || return 1
}

# argParser.setArgVars(): iterates through args and creates variables named according to the switches with
#	values that correspond to the values of the switches
argParser.setArgVars() {
	local key varName value
	for key in ${!argParser_args[*]}
	do
		# strip dashes from front of switch
		varName=$(grep -oP '[^-].*' <<< "$key")
		# get value associated with switch
		value="${argParser_args[$key]}"
		if argParser.isValidVarName $varName; then
			# the variable name looks good; set the variable.
			eval "$varName=\"$value\""
		else
			# notify of failure to stderr
			echo -e "Could not set $varName=$value\n$varName is not a valid variable name" >&2
		fi
	done
}

# argParser.getUnprocessedArgs(): This function looks up who made the call for arguments and
#	then looks up the arguments that are associated with that caller and returns just those 
#	arguments in their unprocessed form.
argParser.getUnprocessedArgs() {
	local caller="$argParser_objName"
	local i=0 skip=0 j=0
	while [ "${FUNCNAME[i]}" != "$caller" ]
	do
		let $[skip+=${BASH_ARGC[i++]}]
	done
	count=${BASH_ARGC[i]}
	j=0
	for i in $(seq $skip $[skip+count-1] | tac)
	do
		argParser_unprocessedArgs[j++]="${BASH_ARGV[$i]}"
	done
}

# look up and the arguments that were associated with the calling script/function
argParser.getUnprocessedArgs

# parse the arguments for the calling script/function
argParser.main "${argParser_unprocessedArgs[@]}"
